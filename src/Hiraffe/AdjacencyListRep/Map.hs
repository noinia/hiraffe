{-# LANGUAGE UndecidableInstances #-}
{-# LANGUAGE TemplateHaskell #-}
--------------------------------------------------------------------------------
-- |
-- Module      :  Hiraffe.AdjacencyListRep.Map
-- Copyright   :  (C) Frank Staals
-- License     :  see the LICENSE file
-- Maintainer  :  Frank Staals
--
-- A Representation of graphs using adjacency lists. The adjacency lists are stored using
-- a Map.
--
--------------------------------------------------------------------------------
module Hiraffe.AdjacencyListRep.Map
  ( Graph
  , GGraph(..)
  , mapNeighbourOrder
  , VertexData(VertexData)
  , mapNeighbourOrder'
  ) where

import           Control.Lens
import           Data.Bifoldable
import           Data.Bitraversable
import qualified Data.Foldable as F
import           Data.Foldable1
import           Data.Functor.Apply (Apply)
import           Data.Functor.Classes
import qualified Data.Map as Map
import           Data.Map.NonEmpty (NEMap)
import qualified Data.Map.NonEmpty as NEMap
import           Data.Maybe (fromMaybe)
import           Data.Monoid
import qualified Data.Sequence as Seq
import           GHC.Generics (Generic)
import           HGeometry.Foldable.Util
import           Hiraffe.Graph.Class

--------------------------------------------------------------------------------

-- | stores the vertex data. the order
data VertexData f i v e = VertexData { _vData      :: !v
                                     , _neighMap   :: Map.Map i e
                                     , _neighOrder :: f i
                                     } deriving (Generic,Functor,Foldable,Traversable)
makeLenses ''VertexData


instance ( Semigroup v, Semigroup e, Semigroup (f i), Ord i
         ) => Semigroup (VertexData f i v e) where
  (VertexData x ns nOrder) <> (VertexData x' ns' nOrder') =
    VertexData (x <> x') (Map.unionWith (<>) ns ns') (nOrder <> nOrder')

instance ( Monoid v, Monoid e, Monoid (f i), Ord i
         ) => Monoid (VertexData f i v e) where
  mempty = VertexData mempty Map.empty mempty


-- | Apply some mapping function over the vertexData
mapNeighbourOrder' :: (f i -> g i) -> VertexData f i v e -> VertexData g i v e
mapNeighbourOrder' f (VertexData x nm os) = VertexData x nm (f os)


instance (Show1 f, Show i, Show v, Show e) => Show (VertexData f i v e) where
  showsPrec d (VertexData v ns nOrd) =
    showParen
          (d >= 11)
          ((.)
             (showString "VertexData ")
             ((.)
                (showsPrec 11 v)
                ((.)
                   showSpace
                   ((.)
                      (showsPrec 11 ns)
                      ((.)
                         showSpace (showsPrec1 11 nOrd))))))
    where
      showSpace = (' ' :)
      -- horrible instance more or less generated by GHC

instance (Eq1 f, Eq i, Eq v, Eq e) => Eq (VertexData f i v e) where
  (VertexData v ns nOrd) == (VertexData v' ns' nOrd') =
    v == v' && liftEq (==) nOrd nOrd' && liftEq (==) ns ns'

instance (Ord1 f, Ord i, Ord v, Ord e) => Ord (VertexData f i v e) where
  (VertexData v ns nOrd) `compare` (VertexData v' ns' nOrd') =
    v `compare` v' <> liftCompare compare nOrd nOrd' <> liftCompare compare ns ns'

instance Bifunctor (VertexData f i) where
  bimap f g (VertexData v ns nOrd) = VertexData (f v) (fmap g ns) nOrd

instance Bifoldable (VertexData f i) where
  bifoldMap f g (VertexData v ns _) = f v <> foldMap g ns

instance Bitraversable (VertexData f i) where
  bitraverse f g (VertexData v ns nOrd) =
    (\v' ns' -> VertexData v' ns' nOrd) <$> f v <*> traverse g ns


--------------------------------------------------------------------------------


-- | A directed graph, whose vertices store data of type v, and are indexed by type i, and
-- whose edges store data of type e. Edges are indexed by an ordered pair of vertex indices.
--
-- The ajdacency lsits are stored using the given 'f' structure.
newtype GGraph f i v e = Graph (NEMap i (VertexData f i v e))
                       deriving (Show,Eq,Generic,Functor,Foldable,Traversable)

-- | A graph in which the adjacency lists are stored using Data.Sequence
type Graph = GGraph Seq.Seq

-- | Iso for accessing the underling NEMap representing the adjacencies
_GraphMap :: Iso (GGraph f i v e)             (GGraph f' i' v' e')
                 (NEMap i (VertexData f i v e)) (NEMap i' (VertexData f' i' v' e'))
_GraphMap = iso (\(Graph m) -> m) Graph

--------------------------------------------------------------------------------

instance Bifunctor (GGraph f i) where
  bimap f g (Graph m) = Graph $ fmap (bimap f g) m

instance Bifoldable (GGraph f i) where
  bifoldMap f g (Graph m) = foldMap (bifoldMap f g) m

instance Bitraversable (GGraph f i) where
  bitraverse f g (Graph m) = Graph <$> traverse (bitraverse f g) m

-- | Apply a mapping function over all neighbourOrder lists in the graph
mapNeighbourOrder :: (f i -> g i) -> GGraph f i v e -> GGraph g i v e
mapNeighbourOrder f (Graph m) = Graph $ fmap (mapNeighbourOrder' f) m

----------------------------------------

instance Ord i => HasVertices' (GGraph f i v e) where
  type Vertex   (GGraph f i v e) = v
  type VertexIx (GGraph f i v e) = i

  -- | \(O(\log n)\)
  vertexAt i = vertexDataOf i <. vData
  numVertices (Graph m) = NEMap.size m

-- | Access the vertex data
vertexDataOf  :: Ord i
              => VertexIx (GGraph f i v e)
              -> IndexedTraversal' (VertexIx (GGraph f i v e))
                                   (GGraph f i v e)
                                   (VertexData f i v e)
vertexDataOf i = _GraphMap .> iixNEMap i

instance Ord i => HasVertices (GGraph f i v e) (GGraph f i v' e) where
  -- | running time: \(O(n)\).
  vertices = conjoined traverse' (itraverse' . indexed)
    where
      traverse'             :: Apply g => (v -> g v') -> GGraph f i v e -> g (GGraph f i v' e)
      traverse' f (Graph m) = Graph <$> NEMap.traverseWithKey1 (\_ vd -> vd&vData %%~ f) m

      itraverse'             :: Apply g => (i -> v -> g v') -> GGraph f i v e -> g (GGraph f i v' e)
      itraverse' f (Graph m) = Graph <$> NEMap.traverseWithKey1 (\i vd -> vd&vData %%~ f i) m
  {-# INLINE vertices #-}


----------------------------------------

instance Ord i => HasDarts' (GGraph f i v e) where
  type Dart   (GGraph f i v e) = e
  type DartIx (GGraph f i v e) = (VertexIx (GGraph f i v e), VertexIx (GGraph f i v e))
                          -- lexicographical index

  -- | running time: \(O(\log m)\)
  dartAt (u,v) = vertexDataOf u <.> neighMap .> iix v
  {-# INLINE dartAt #-}

  -- | running time: O(n)
  numDarts (Graph m) = getSum . foldMap (Sum . lengthOf neighMap) $ m

instance Ord i => HasDarts (GGraph f i v e) (GGraph f i v e') where
  -- | running time: \(O(m)\)
  darts pefe' (Graph m) = Graph <$> NEMap.traverseWithKey f m
    where
      f u vd = vd&neighMap.itraversed %%@~ \v e -> indexed pefe' (u,v) e
  {-# INLINE darts #-}



----------------------------------------

instance Ord i => HasEdges' (GGraph f i v e) where
  type Edge   (GGraph f i v e) = Dart   (GGraph f i v e)
  type EdgeIx (GGraph f i v e) = DartIx (GGraph f i v e)

  -- | running time: \(O(\log m)\)
  edgeAt e@(u',v') = let (u,v) = if u' <= v' then e else (v',u')
                     in vertexDataOf u <.> neighMap .> iix v

instance Ord i => HasEdges (GGraph f i v e) (GGraph f i v e') where
  -- | running time: \(O(m)\)
  edges pefe' = fmap linkNegatives . darts (Indexed h)
    where
      h e@(u,v) x | u <= v    = Just <$> indexed pefe' e x
                  | otherwise = pure Nothing
      -- we compute the value only for the positive edges (i.e. u <=
      -- v), and wrap them in a Just. For the negative values we just
      -- store Nothings. We then use linkNegatives to, for each
      -- negative edge look up the value stored at the postiive edge.
  {-# INLINE edges #-}

-- | for each negative edge (v,u) look up the value stored at (u,v)
-- and store it here.
linkNegatives   :: Ord i => GGraph f i v (Maybe e') -> GGraph f i v e'
linkNegatives g = g&darts %@~ \(u,v) x -> if u <= v then fromJust' x
                                                    else fromJust' $ g^?!dartAt (v,u)
  where
    fromJust' = fromMaybe (error "Hiraffe.AdjacencyListRep.Map.edges: absurd ; fromJust")

--------------------------------------------------------------------------------

instance Ord i => DiGraph_ (GGraph f i v e) where
  type DiGraphFromAdjListExtraConstraints (GGraph f i v e) h = HasFromFoldable f
  diGraphFromAdjacencyLists =
    Graph . foldMap1 (\(i,v,adjs) -> let vd = VertexData v (mkNeighMap adjs) (mkNeighOrder adjs)
                                     in NEMap.singleton i vd
                     )
    where
      mkNeighMap   = foldMap (uncurry Map.singleton)
      mkNeighOrder = fromList . map fst . F.toList

  endPoints _ = id
  outNeighboursOf u = conjoined asFold asIFold
    where
      asFold  :: Fold (GGraph f i v e) v
      asFold  = folding  $ \g -> g^..incidentEdges' u.asIndex.to (\v -> g^?! vertexAt v)
      asIFold = ifolding $ \g -> g^..incidentEdges' u.asIndex.to (\v -> (v, g^?! vertexAt v))
  {-# INLINE outNeighboursOf #-}

  twinDartOf (u,v) = to $ \g -> g^?dartAt (v,u).asIndex
    -- just look up the dart v,u


instance Ord i => BidirGraph_ (GGraph f i v e) where
  twinOf (u,v) = to $ const (v,u)
  getPositiveDart _ d@(u,v) | u <= v    = d
                            | otherwise = (v,u)
  -- we use the dart oriented from small to large as the positive one.

instance Ord i => Graph_ (GGraph f i v e) where
  type GraphFromAdjListExtraConstraints (GGraph f i v e) h = HasFromFoldable f
  fromAdjacencyLists =
    Graph . foldMap1 (\(i,v,adjs) -> let vd = VertexData v (mkNeighMap adjs) (mkNeighOrder adjs)
                                     in NEMap.singleton i vd
                     )
    where
      mkNeighMap   = foldMap (uncurry Map.singleton)
      mkNeighOrder = fromList . map fst . F.toList

  neighboursOf u = conjoined asFold asIFold
    where
      asFold  :: Fold (GGraph f i v e) v
      asFold  = folding  $ \g -> g^..incidentEdges' u.asIndex.to (\v -> g^?! vertexAt v)
      asIFold = ifolding $ \g -> g^..incidentEdges' u.asIndex.to (\v -> (v, g^?! vertexAt v))
  {-# INLINE neighboursOf #-}

  incidentEdgesOf u = reindexed (u,) (incidentEdges' u)


-- | A traversal of the edges incident to vertex u as an intexed by the other vertex
incidentEdges'  :: Ord i
                => VertexIx (GGraph f i v e)
                -> IndexedTraversal' (VertexIx (GGraph f i v e)) (GGraph f i v e) e
-- incidentEdges'  :: (Indexable (VertexIx (GGraph f v e)) p, Applicative g)
--                 => VertexIx (GGraph f v e) -> p e (g e) -> GGraph f v e -> g (GGraph f v e)
incidentEdges' u = vertexDataOf u.neighMap.itraversed


--------------------------------------------------------------------------------
-- Combining Graphs


instance ( Ord i, Semigroup v, Semigroup e, Semigroup (f i)
         ) => Semigroup (GGraph f i v e) where
  (Graph m) <> (Graph m') = Graph $ NEMap.unionWith (<>) m m'


--------------------------------------------------------------------------------
-- essentially inlining ix and iix for NEMap; since there is no Indexed
-- instance for these types

ixNEMap       :: Ord k => k -> Traversal' (NEMap k a) a
ixNEMap k f m = case NEMap.lookup k m of
     Just v  -> f v <&> \v' -> NEMap.insert k v' m
     Nothing -> pure m
{-# INLINE ixNEMap #-}

iixNEMap     :: Ord k => k -> IndexedTraversal' k (NEMap k a) a
iixNEMap i f = ixNEMap i (indexed f i)
{-# INLINE iixNEMap #-}

-- -- | The 'IndexedTraversal' of a 'TraversableWithIndex' container.
-- itraversedNEMap :: Ord i => IndexedTraversal i (NEMap i a) (NEMap i b) a b
-- itraversedNEMap = conjoined traverse (NEMap.traverseWithKey . indexed)
-- {-# INLINE [0] itraversedNEMap #-}

-- -- | The 'IndexedTraversal' of a 'TraversableWithIndex' container.
-- itraversedNEMap1 :: Ord i => IndexedTraversal1 i (NEMap i a) (NEMap i b) a b
-- itraversedNEMap1 = conjoined traverse1 (NEMap.traverseWithKey1 . indexed)
-- {-# INLINE [0] itraversedNEMap1 #-}


----------------------------------------
